import {
  require_react_dom,
  require_scheduler
} from "./chunk-NFVHRS7X.js";
import {
  require_prop_types
} from "./chunk-XAUU4KKC.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React4 = require_react();
        var ReactSharedInternals = React4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState2 = React4.useState, useEffect2 = React4.useEffect, useLayoutEffect = React4.useLayoutEffect, useDebugValue = React4.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React4.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState2({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect2(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React4.useSyncExternalStore !== void 0 ? React4.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/react-sweet-state/lib/esm/components/container.js
var import_react3 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/react-sweet-state/lib/esm/context.js
var import_react2 = __toESM(require_react());

// node_modules/react-sweet-state/lib/esm/defaults.js
var import_react = __toESM(require_react());
var defaultMutator = (prevState, partialState) => {
  return Object.assign({}, prevState, partialState);
};
var defaults = {
  batchUpdates: "useSyncExternalStore" in import_react.default,
  devtools: false,
  middlewares: /* @__PURE__ */ new Set(),
  mutator: defaultMutator
};
var defaults_default = defaults;

// node_modules/react-sweet-state/lib/esm/store/bind-actions.js
var namedMutator = (storeState, actionName) => function() {
  storeState.mutator.actionName = actionName;
  return storeState.mutator(...arguments);
};
var warnings = /* @__PURE__ */ new WeakMap();
var bindAction = (storeState, actionFn, actionKey, config, actions) => {
  const callThunk = (instance, thunkFn, actionName) => thunkFn({
    setState: defaults_default.devtools ? namedMutator(instance.storeState, actionName) : instance.storeState.mutator,
    getState: instance.storeState.getState,
    get actions() {
      if (!warnings.has(actionFn)) {
        warnings.set(actionFn, console.warn(`react-sweet-state 'actions' property has been deprecated and will be removed in the next mayor. Please check action '${actionName}' of Store '${instance.storeState.key}' and use 'dispatch' instead`));
      }
      return actions;
    },
    dispatch: (tFn) => callThunk(instance, tFn, `${actionName}.dispatch`)
  }, config.props());
  return function() {
    return callThunk({
      storeState,
      actions
    }, actionFn(...arguments), actionKey);
  };
};
var bindActions = function bindActions2(actions, storeState, config, boundActions) {
  if (boundActions === void 0) {
    boundActions = null;
  }
  return Object.keys(actions).reduce((acc, k) => {
    acc[k] = bindAction(storeState, actions[k], k, config, boundActions || acc);
    return acc;
  }, {});
};

// node_modules/react-sweet-state/lib/esm/utils/hash.js
function murmurhash2_32_gc(str) {
  var l = str.length, h = l ^ l, i = 0, k;
  while (l >= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
    k ^= k >>> 24;
    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
    h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
    l -= 4;
    ++i;
  }
  switch (l) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
  h ^= h >>> 15;
  return (h >>> 0).toString(36);
}

// node_modules/react-sweet-state/lib/esm/store/create.js
function createKey(initialState, actions, name) {
  const src = !name ? Object.keys(actions).reduce((acc, k) => acc + actions[k].toString(), "") : "";
  return [name, murmurhash2_32_gc(src + JSON.stringify(initialState))].filter(Boolean).join("__");
}
function createStore(_ref) {
  let {
    name = "",
    initialState,
    actions,
    containedBy,
    handlers = {}
  } = _ref;
  let key;
  return {
    get key() {
      return key || (key = createKey(initialState, actions, name));
    },
    initialState,
    actions,
    containedBy,
    handlers
  };
}

// node_modules/react-sweet-state/lib/esm/utils/supported-features.js
var supports = {
  scheduling() {
    return typeof window !== "undefined" && typeof MessageChannel === "function";
  }
};
var supported_features_default = supports;

// node_modules/react-sweet-state/lib/esm/utils/shallow-equal.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var CACHE = /* @__PURE__ */ new WeakMap();
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (Array.isArray(objA) && Array.isArray(objB)) {
    if (objA.length !== objB.length) {
      return false;
    }
    for (let i = 0; i < objA.length; i++) {
      if (objA[i] !== objB[i]) {
        return false;
      }
    }
    return true;
  } else {
    const strA = "" + objA;
    const strB = "" + objB;
    if (strA !== strB || strA[0] === "[" && strA !== "[object Object]") {
      return false;
    }
    let keysA;
    if (CACHE.has(objA)) {
      keysA = CACHE.get(objA);
    } else {
      keysA = Object.keys(objA);
      CACHE.set(objA, keysA);
    }
    let keysB;
    if (CACHE.has(objB)) {
      keysB = CACHE.get(objB);
    } else {
      keysB = Object.keys(objB);
      CACHE.set(objB, keysB);
    }
    if (keysA.length !== keysB.length) {
      return false;
    }
    for (let i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
}

// node_modules/react-sweet-state/lib/esm/middlewares/update.js
var updateMiddleware = (storeState) => (next) => (arg) => {
  let output;
  const state = storeState.getState();
  const nextState = next(state, arg, (out) => {
    output = out;
  });
  if (!shallowEqual(nextState, state)) {
    storeState.setState(nextState);
  }
  return output;
};
var update_default = updateMiddleware;

// node_modules/react-sweet-state/lib/esm/middlewares/index.js
var applyMiddleware = (storeState, middlewares) => Array.from(middlewares).concat(update_default).reduceRight((next, mw) => mw(storeState)(next), defaults_default.mutator);
var middlewares_default = applyMiddleware;

// node_modules/react-sweet-state/lib/esm/enhancers/devtools.js
var connectDevTools = (storeState, config) => {
  const devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect(Object.assign({
    name: `Store ${storeState.key}`,
    serialize: true,
    trace: true
  }, config));
  devTools.init(storeState.getState());
  devTools.subscribe((message) => {
    if (message.type === "DISPATCH") {
      switch (message.payload.type) {
        case "RESET":
          storeState.resetState();
          devTools.init(storeState.getState());
          return;
        case "COMMIT":
          devTools.init(storeState.getState());
          return;
        case "ROLLBACK":
          storeState.setState(JSON.parse(message.state));
          devTools.init(storeState.getState());
          return;
        case "JUMP_TO_STATE":
        case "JUMP_TO_ACTION":
          storeState.setState(JSON.parse(message.state));
          return;
      }
    } else if (message.type === "ACTION") {
      let action = JSON.parse(message.payload);
      storeState.setState(action.payload);
    }
  });
  return devTools;
};
var withDevtools = (createStoreState2) => function() {
  const storeState = createStoreState2(...arguments);
  if (defaults_default.devtools && window && window.__REDUX_DEVTOOLS_EXTENSION__) {
    const origMutator = storeState.mutator;
    let devTools;
    const devtoolMutator = (arg) => {
      const result = origMutator(arg);
      try {
        if (!devTools) {
          const config = typeof defaults_default.devtools === "function" ? defaults_default.devtools(storeState) : {};
          devTools = connectDevTools(storeState, config);
        }
        devTools.send({
          type: storeState.mutator.actionName,
          payload: arg
        }, storeState.getState(), {}, storeState.key);
      } catch (err) {
      }
      return result;
    };
    storeState.mutator = devtoolMutator;
  }
  return storeState;
};
var devtools_default = withDevtools;

// node_modules/react-sweet-state/lib/esm/utils/batched-updates.js
var import_react_dom = __toESM(require_react_dom());
var import_scheduler = __toESM(require_scheduler());
var isInsideBatchedSchedule = false;
function batch(fn) {
  if (!defaults_default.batchUpdates || !supported_features_default.scheduling() || isInsideBatchedSchedule) {
    return (0, import_react_dom.unstable_batchedUpdates)(fn);
  }
  isInsideBatchedSchedule = true;
  return (0, import_scheduler.unstable_scheduleCallback)(import_scheduler.unstable_ImmediatePriority, function scheduleBatchedUpdates() {
    (0, import_react_dom.unstable_batchedUpdates)(fn);
    isInsideBatchedSchedule = false;
  });
}

// node_modules/react-sweet-state/lib/esm/utils/schedule.js
var QUEUE = [];
var scheduled;
function schedule(fn) {
  if (!defaults_default.batchUpdates || !supported_features_default.scheduling())
    return batch(() => fn());
  if (!QUEUE.includes(fn))
    QUEUE.push(fn);
  if (scheduled)
    return;
  scheduled = batch(() => {
    let queueFn;
    while (queueFn = QUEUE.shift())
      queueFn();
    scheduled = null;
  });
}

// node_modules/react-sweet-state/lib/esm/store/create-state.js
function createStoreState(key, initialState) {
  let listeners = /* @__PURE__ */ new Set();
  let currentState = initialState;
  const storeState = {
    key,
    getState() {
      return currentState;
    },
    setState(nextState) {
      currentState = nextState;
      schedule(storeState.notify);
    },
    resetState() {
      storeState.setState(initialState);
    },
    notify() {
      for (const listener of listeners) {
        listener(storeState.getState());
      }
    },
    subscribe(listener) {
      listeners.add(listener);
      return function unsubscribe() {
        listeners.delete(listener);
      };
    },
    listeners() {
      return listeners;
    }
  };
  storeState.mutator = middlewares_default(storeState, defaults_default.middlewares);
  return storeState;
}
var create_state_default = devtools_default(createStoreState);

// node_modules/react-sweet-state/lib/esm/store/registry.js
var GLOBAL_SCOPE = "__global__";
var StoreRegistry = class {
  constructor(defaultScope) {
    var _this = this;
    if (defaultScope === void 0) {
      defaultScope = GLOBAL_SCOPE;
    }
    this.stores = /* @__PURE__ */ new Map();
    this.initStore = (key, Store, config) => {
      const {
        initialState,
        actions
      } = Store;
      if (Store.containedBy && !config.contained(Store)) {
        const err = new Error(`Store ${Store.key} should be contained by a container but it is used globally. While it might still work, it will likely cause unexpected behaviours.`);
        if (supported_features_default.scheduling())
          Promise.reject(err);
        else
          throw err;
      }
      const storeState = create_state_default(key, initialState);
      let boundActions;
      const store = {
        storeState,
        // these are used only when container-less, so we generate them on-demand
        get actions() {
          if (!boundActions)
            boundActions = bindActions(actions, storeState, config);
          return boundActions;
        }
      };
      this.stores.set(key, store);
      return store;
    };
    this.hasStore = function(Store, scopeId) {
      if (scopeId === void 0) {
        scopeId = _this.defaultScope;
      }
      const key = _this.generateKey(Store, scopeId);
      return _this.stores.has(key);
    };
    this.getStore = function(Store, scopeId, config) {
      if (scopeId === void 0) {
        scopeId = _this.defaultScope;
      }
      if (config === void 0) {
        config = {
          props: () => ({}),
          contained: () => false
        };
      }
      const key = _this.generateKey(Store, scopeId);
      return _this.stores.get(key) || config && _this.initStore(key, Store, config);
    };
    this.deleteStore = function(Store, scopeId) {
      if (scopeId === void 0) {
        scopeId = _this.defaultScope;
      }
      const key = _this.generateKey(Store, scopeId);
      _this.stores.delete(key);
    };
    this.generateKey = (Store, scopeId) => `${Store.key}@${scopeId}`;
    this.defaultScope = defaultScope;
  }
};
var defaultRegistry = new StoreRegistry();

// node_modules/react-sweet-state/lib/esm/context.js
var Context = import_react2.default.createContext({
  globalRegistry: defaultRegistry,
  retrieveStore: (Store) => defaultRegistry.getStore(Store)
}, () => 0);

// node_modules/react-sweet-state/lib/esm/components/container.js
var _excluded = ["children"];
var _excluded2 = ["scope", "isGlobal"];
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var noop = () => () => {
};
function createContainer(StoreOrOptions, _temp) {
  if (StoreOrOptions === void 0) {
    StoreOrOptions = {};
  }
  let {
    onInit: _onInit = noop,
    onUpdate = noop,
    onCleanup = noop,
    displayName = ""
  } = _temp === void 0 ? {} : _temp;
  if ("key" in StoreOrOptions) {
    const Store = StoreOrOptions;
    const dn = displayName || `Container(${Store.key.split("__")[0]})`;
    return createFunctionContainer({
      displayName: dn,
      // compat fields
      override: {
        Store,
        handlers: Object.assign(
          {},
          _onInit !== noop && {
            onInit: () => _onInit()
          },
          onCleanup !== noop && {
            onDestroy: () => onCleanup()
          },
          // TODO: on next major pass through next/prev props args
          onUpdate !== noop && {
            onContainerUpdate: () => onUpdate()
          }
        )
      }
    });
  }
  return createFunctionContainer(StoreOrOptions);
}
function useRegistry(scope, isGlobal, _ref) {
  let {
    globalRegistry
  } = _ref;
  return (0, import_react3.useMemo)(() => {
    const isLocal = !scope && !isGlobal;
    return isLocal ? new StoreRegistry("__local__") : globalRegistry;
  }, [scope, isGlobal, globalRegistry]);
}
function useContainedStore(scope, registry, propsRef, check, override) {
  const containedStores = (0, import_react3.useMemo)(() => /* @__PURE__ */ new Map(), [scope]);
  const getContainedStore = (0, import_react3.useCallback)((Store) => {
    let containedStore = containedStores.get(Store);
    if (!containedStore) {
      const isExisting = registry.hasStore(Store, scope);
      const config = {
        props: () => propsRef.current.sub,
        contained: check
      };
      const {
        storeState
      } = registry.getStore(Store, scope, config);
      const actions = bindActions(Store.actions, storeState, config);
      const handlers = bindActions(Object.assign({}, Store.handlers, override == null ? void 0 : override.handlers), storeState, config, actions);
      containedStore = {
        storeState,
        actions,
        handlers,
        unsubscribe: storeState.subscribe(() => handlers.onUpdate == null ? void 0 : handlers.onUpdate())
      };
      containedStores.set(Store, containedStore);
      if (!isExisting || override)
        handlers.onInit == null ? void 0 : handlers.onInit();
    }
    return containedStore;
  }, [containedStores, scope, registry, propsRef, check, override]);
  return [containedStores, getContainedStore];
}
function useApi(check, getContainedStore, _ref2) {
  let {
    globalRegistry,
    retrieveStore
  } = _ref2;
  const retrieveRef = (0, import_react3.useRef)();
  retrieveRef.current = (Store) => check(Store) ? getContainedStore(Store) : retrieveStore(Store);
  return (0, import_react3.useMemo)(() => ({
    globalRegistry,
    retrieveStore: (s) => retrieveRef.current(s)
  }), [globalRegistry]);
}
function createFunctionContainer(_temp2) {
  let {
    displayName,
    override
  } = _temp2 === void 0 ? {} : _temp2;
  const check = (store) => override ? store === override.Store : store.containedBy === FunctionContainer;
  function FunctionContainer(props) {
    const {
      children
    } = props, restProps = _objectWithoutPropertiesLoose(props, _excluded);
    const {
      scope,
      isGlobal
    } = restProps, subProps = _objectWithoutPropertiesLoose(restProps, _excluded2);
    const ctx = (0, import_react3.useContext)(Context);
    const registry = useRegistry(scope, isGlobal, ctx);
    const propsRef = (0, import_react3.useRef)({
      prev: null,
      next: restProps,
      sub: subProps
    });
    propsRef.current = {
      prev: propsRef.current.next,
      next: restProps,
      sub: subProps
      // TODO remove on next major
    };
    const [containedStores, getContainedStore] = useContainedStore(scope, registry, propsRef, check, override);
    const api = useApi(check, getContainedStore, ctx);
    if (!shallowEqual(propsRef.current.next, propsRef.current.prev)) {
      containedStores.forEach((_ref3) => {
        let {
          handlers
        } = _ref3;
        handlers.onContainerUpdate == null ? void 0 : handlers.onContainerUpdate(propsRef.current.next, propsRef.current.prev);
      });
    }
    if (override && !containedStores.size && (scope || isGlobal)) {
      getContainedStore(override.Store);
    }
    (0, import_react3.useEffect)(() => {
      return () => {
        containedStores.forEach((_ref4, Store) => {
          let {
            storeState,
            handlers,
            unsubscribe
          } = _ref4;
          unsubscribe();
          storeState.notify();
          Promise.resolve().then(() => {
            var _registry$getStore;
            if (!storeState.listeners().size && // ensure registry has not already created a new store with same scope
            storeState === ((_registry$getStore = registry.getStore(Store, scope, null)) == null ? void 0 : _registry$getStore.storeState)) {
              handlers.onDestroy == null ? void 0 : handlers.onDestroy();
              if (scope)
                registry.deleteStore(Store, scope);
            }
          });
        });
      };
    }, [registry, scope, containedStores]);
    return import_react3.default.createElement(Context.Provider, {
      value: api
    }, children);
  }
  FunctionContainer.displayName = displayName || `Container`;
  FunctionContainer.propTypes = {
    children: import_prop_types.default.node,
    scope: import_prop_types.default.string,
    isGlobal: import_prop_types.default.bool
  };
  return FunctionContainer;
}

// node_modules/react-sweet-state/lib/esm/components/hook.js
var import_react4 = __toESM(require_react());
var import_shim = __toESM(require_shim());

// node_modules/react-sweet-state/lib/esm/utils/memoize.js
function exactEqual(objA, objB) {
  return objA === objB;
}
function areArgumentsEqual(propsMode, prev, next) {
  if (prev === null || next === null || prev.length !== next.length)
    return false;
  if (propsMode && prev.length === 2) {
    return prev[0] === next[0] && shallowEqual(prev[1], next[1]);
  }
  for (let i = 0; i < prev.length; i++) {
    if (!exactEqual(prev[i], next[i]))
      return false;
  }
  return true;
}
function memoize_default(resultFn, propsMode) {
  if (propsMode === void 0) {
    propsMode = false;
  }
  let lastArgs = [];
  let lastResult;
  let calledOnce = false;
  const result = function result2() {
    if (calledOnce && areArgumentsEqual(propsMode, arguments, lastArgs)) {
      return lastResult;
    }
    const nextResult = resultFn.apply(this, arguments);
    if (!propsMode && shallowEqual(nextResult, lastResult)) {
      return lastResult;
    }
    lastResult = nextResult;
    calledOnce = true;
    lastArgs = arguments;
    return lastResult;
  };
  return result;
}

// node_modules/react-sweet-state/lib/esm/utils/create-selector.js
function createSelector() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  const resultFunc = funcs.pop();
  const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  const memoizedResultFunc = memoize_default(function() {
    return resultFunc.apply(null, arguments);
  });
  const selector = memoize_default(function() {
    const params = [];
    for (let i = 0; i < dependencies.length; i++) {
      params.push(dependencies[i].apply(null, arguments));
    }
    return memoizedResultFunc.apply(null, params);
  }, true);
  selector.resultFunc = resultFunc;
  selector.dependencies = dependencies;
  return selector;
}
function createMemoizedSelector(selector) {
  const isReselector = typeof selector.resultFunc === "function" && Array.isArray(selector.dependencies);
  const dependencies = isReselector ? selector.dependencies : [(s) => s, (_, p) => p];
  const resultFunc = isReselector ? selector.resultFunc : selector;
  return createSelector(dependencies, resultFunc);
}
var cache = /* @__PURE__ */ new WeakMap();
function getSelectorInstance(selector, storeState, hasProps) {
  if (!hasProps) {
    if (!cache.has(storeState)) {
      cache.set(storeState, /* @__PURE__ */ new WeakMap());
    }
    const scopeSelectors = cache.get(storeState);
    if (!scopeSelectors.has(selector)) {
      scopeSelectors.set(selector, createMemoizedSelector(selector));
    }
    return scopeSelectors.get(selector);
  }
  return createMemoizedSelector(selector);
}

// node_modules/react-sweet-state/lib/esm/components/hook.js
var EMPTY_SELECTOR = () => void 0;
var DEFAULT_SELECTOR = (state) => state;
function createHook(Store, _temp) {
  let {
    selector
  } = _temp === void 0 ? {} : _temp;
  return function useSweetState(propsArg) {
    const {
      retrieveStore
    } = (0, import_react4.useContext)(Context);
    const {
      storeState,
      actions
    } = retrieveStore(Store);
    const hasPropsArg = propsArg !== void 0;
    const propsArgRef = (0, import_react4.useRef)(propsArg);
    propsArgRef.current = propsArg;
    const stateSelector = (0, import_react4.useMemo)(() => selector ? getSelectorInstance(selector, storeState, hasPropsArg) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR, [hasPropsArg, storeState]);
    const forceUpdate = (0, import_react4.useState)({})[1];
    const getSnapshot = (0, import_react4.useCallback)(() => {
      if (retrieveStore(Store).storeState !== storeState)
        forceUpdate({});
      const state = storeState.getState();
      return stateSelector(state, propsArgRef.current);
    }, [retrieveStore, storeState, stateSelector, forceUpdate]);
    const currentState = (0, import_shim.useSyncExternalStore)(storeState.subscribe, getSnapshot, getSnapshot);
    return [currentState, actions];
  };
}
function createActionsHook(Store) {
  const useHook = createHook(Store, {
    selector: null
  });
  return function useSweetStateActions() {
    return useHook()[1];
  };
}
function createStateHook(Store, _temp2) {
  let {
    selector
  } = _temp2 === void 0 ? {} : _temp2;
  const useHook = createHook(Store, {
    selector
  });
  return function useSweetStateState(propsArg) {
    return useHook(propsArg)[0];
  };
}

// node_modules/react-sweet-state/lib/esm/components/subscriber.js
var _excluded3 = ["children"];
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function hasAdditionalProps(props) {
  for (let i in props)
    return true;
  return false;
}
function createSubscriber(Store, _temp) {
  let {
    selector,
    displayName = ""
  } = _temp === void 0 ? {} : _temp;
  const useStore = createHook(Store, {
    selector
  });
  const Subscriber = function Subscriber2(_ref) {
    let {
      children
    } = _ref, rest = _objectWithoutPropertiesLoose2(_ref, _excluded3);
    const api = useStore(hasAdditionalProps(rest) ? rest : void 0);
    return children(...api);
  };
  Subscriber.displayName = displayName || `Subscriber(${Store.key.split("__")[0]})`;
  return Subscriber;
}
export {
  batch,
  createActionsHook,
  createContainer,
  createHook,
  createSelector,
  createStateHook,
  createStore,
  createSubscriber,
  defaultRegistry,
  defaults_default as defaults
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-sweet-state.js.map
